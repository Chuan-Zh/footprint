#!/usr/bin/env python
"""
This file deals with operon graph, where nodes is operon, and edge has multiplicity.
In the original regulon graph, we split each regulon to motifs and build a graph, 
the edges will keep the information which two motifs are actually similar.
Do some basic analysis on this graph and regulon subgraph.
"""
import networkx as nx
from collections import defaultdict
from sets import Set

def operon_graph(file, similarity_cutoff = -1.0, zscore_cutoff = -1.0):
    """Create motif graph from file"""
    G = nx.Graph()

    datafile = open(file)
    next(datafile)
    for line in datafile:
        line = line.rstrip('\n\r')
        gi1, gi2, similarity, zscore, multiplicity, in_regulon, names = line.split('\t')

        if (zscore == ''):continue
        if (similarity < similarity_cutoff or zscore < zscore_cutoff): continue

        G.add_edge(gi1, gi2, similarity=float(similarity), zscore=float(zscore), in_regulon=in_regulon, names=names)

    datafile.close()
    return G

def operon_nodes(file, similarity_cutoff = -1.0, zscore_cutoff = -1.0):
    """nodes correspond to an operon"""
    rv = defaultdict(Set)
    with open(file) as f:
        next(f)
        for line in f:
            line = line.rstrip('\n\r')
            gi1, gi2, similarity, zscore, in_regulon, names = line.split('\t')

            if (zscore == ''):continue
            if (similarity < similarity_cutoff or zscore < zscore_cutoff): continue

            (g1, m1) = gi1.split('_')
            (g2, m2) = gi2.split('_')


            rv[g1].add(gi1)
            rv[g2].add(gi2)

    return rv


def read_regulon(file="../data/regulon_by_first_gene.txt"):
    rv = {}
    reg_now = ''

    datafile = open(file)
    for line in datafile:
        line = line.rstrip('\n\r')
        if line.startswith('>'):
            reg_now = line[1:]
        else:
            rv[reg_now] = line.lstrip().split()

    return rv

def read_regulon_g2r(file="../data/regulon_by_first_gene.txt"):
    rv = {}
    reg_now = ''

    datafile = open(file)
    for line in datafile:
        line = line.rstrip('\n\r')
        if line.startswith('>'):
            reg_now = line[1:]
        else:
            for gi in line.lstrip().split():
                if gi in rv: rv[gi] += ('_' + reg_now)
                else: rv[gi] = reg_now

    return rv

def edge_density(edge_n, node_n):
    """probobility of having an edge between two nodes"""
    try:
        rv = 2.0 * edge_n / (node_n * (node_n - 1))
    except ZeroDivisionError:
        sys.stderr.write("graph has 0 node, return 0 for edge density")
        rv = 0

    return rv

def edge_average_zscore(graph):
    """average zscore of all edges"""
    n_edges = graph.number_of_edges()
    rv = 0

    if n_edges == 0:
        return -1
    else:
        for i in graph.edges(data=True):
            rv += i[2]['zscore']

    return rv / n_edges

def read_LOO(file):
    rv = {}
    f=open(file)
    for l in f:
        l = l.rstrip()
        (reg, loo) = l.split()
        rv[reg] = float(loo)

    return rv

def count_common_neighbors(G, a, b):
    return len( filter(lambda x: x in G.neighbors(b), G.neighbors(a)) )

if __name__ == "__main__":

    import networkx as nx
    import sys
    import os
    from pprint import pprint

    try:
        crs_f = sys.argv[1]
        similarity_cutoff = sys.argv[2]
        zscore_cutoff = sys.argv[3]
    except IndexError:
        sys.exit("Motif graph propertys\npython %s <tsv file generated by edges2table.pl> similarity_cutoff zscore_cutoff" % (sys.argv[0]))

    opr_nodes = operon_nodes(crs_f, similarity_cutoff, zscore_cutoff)
    #pprint(opr_nodes)
    G = motif_graph(crs_f, similarity_cutoff, zscore_cutoff)

    loo_f = "../../data/LOO_per_matrix_site.tsv"
    regulon_f = "../../data/regulon_by_first_gene.txt"
    LOO = read_LOO(loo_f)
    regulon = read_regulon(regulon_f)

    print("#graph has %d nodes with %d edges, edges to nodes ratio: %f, edge average zscore: %f"\
            %(nx.number_of_nodes(G),
                nx.number_of_edges(G),
                edge_density(nx.number_of_edges(G), nx.number_of_nodes(G)),
                edge_average_zscore(G)))
    print("#", nx.number_connected_components(G),"connected components")


    print("reg\tLOO\tsize\tnodes\tedges\tratio\tavg_zscore\tnumber_connected_components\tlargest_comp_size")

    for reg in regulon.keys():
        if len(regulon[reg]) > 2:
            nodes = list()
            for gi in regulon[reg]:
                for n in opr_nodes[gi]:
                    nodes.append(n)

            H = G.subgraph(nodes)

            comp = nx.connected_components(H)

            largest_comp_size = len(comp[0])

            loo = -1
            if reg in LOO: loo = LOO[reg]

            print("%s\t%g\t%d\t%d\t%d\t%f\t%f\t%i\t%i"\
                    %(reg,
                        loo,
                        len(regulon[reg]),
                        nx.number_of_nodes(H),
                        nx.number_of_edges(H),
                        edge_density(nx.number_of_edges(H), nx.number_of_nodes(H)),
                        edge_average_zscore(H),
                        nx.number_connected_components(H),
                        largest_comp_size))


